Index: prs74.c
===================================================================
--- prs74.c	(revision 9794)
+++ prs74.c	(working copy)
@@ -30,8 +30,12 @@
 // macros.
 
 // globals.
+#define IR_DATA_BIT_COUNT	8
+ 
+uint16_t encoded_data;
+unsigned int transfer_count;
+unsigned int ir_counter = 0;
 
-
 // functions.
 void PRSInit();
 void PRSRun();
@@ -46,11 +50,63 @@
 /* dy */
 volatile sens_SSimpSample sensors={}; /* {} seems neccessary??? */
 
+static void encode( uint8_t data )
+{
+	int hamming_exp = 0, p_data_bits = 0, transfer_bit_count, i, j, parity, pos;
+	encoded_data = 0;
+
+	for (transfer_bit_count = 0; p_data_bits < IR_DATA_BIT_COUNT; transfer_bit_count++)
+	{
+		if ((transfer_bit_count + 1) == (1<<hamming_exp))
+			hamming_exp++;
+		else
+		{
+			encoded_data |= ((uint16_t) (data>>p_data_bits)&1) <<transfer_bit_count;
+			p_data_bits++;
+		}
+	}
+//assert(hamming_exp<=4)
+	for (i = 0; i < hamming_exp; i++)
+	{
+		pos = (1<<i) - 1;
+		encoded_data |= 1L<<pos;
+		for (j = pos + 1; j < transfer_bit_count; j++)
+		{
+			if (((j + 1) & (1<<i)) && (encoded_data>>j) & 1)
+				encoded_data ^= 1L<<pos;
+		}
+	}
+
+	parity = 0;
+	for (i = 0; i < transfer_bit_count; i++)
+		parity ^= encoded_data >> i;
+
+	encoded_data |= ((uint16_t) (parity & 1)) << transfer_bit_count;
+	transfer_bit_count++;
+	transfer_count = 2 * transfer_bit_count + 3;
+}
+
+static int getIRProtocolBit(uint8_t index)
+{
+	uint16_t ret;
+	
+	if (index == 0 || index == 1)
+		return 1;
+	else if ((index % 2) == 0)
+		return 0;	
+	else
+	{
+	    ret=(encoded_data>>((index - 3)/2));
+		return ret&1;
+    }		
+}
+
 void PRSInit()
 {
 init_sensors();
 init_time();
 ACLSubscribe(ACL_TYPE_ALPHA_ARG('S','V','C'));
+encode(ACLGetLocalId()[7]);
 }
 
 int has_dat=0,send_enough=0;
@@ -59,6 +115,17 @@
 
 void PRSRun()
 {
+	if ((PRS_slot_counter & 1) == 1)
+	{
+		if (getIRProtocolBit( ir_counter ))
+			output_high( PIN_LED_ONE_POWER );
+		else
+			output_low( PIN_LED_ONE_POWER );
+
+		ir_counter++;
+		ir_counter = ir_counter % transfer_count;	
+	}
+
    ++PRS_slot_counter;
    if((PRS_slot_counter&0xff)==0)
 	   update_time(); //every 3 seconds, later may need wakeup...
@@ -67,11 +134,6 @@
 
  has_dat=!get_sensor_values(&sensors, PRS_slot_counter%(1<<15));
 
- if(PRS_slot_counter%(1<<3))
- {
-	if(PRS_slot_counter&(1<<3)) output_high(PIN_LED_ONE_POWER); else output_low(PIN_LED_ONE_POWER);
- }
-
 #ifdef PIN_LED_AMBER_POWER
    if(has_dat) SSimpLEDAmberOn();
    else  SSimpLEDAmberOff();
Index: prs_app.c
===================================================================
--- prs_app.c	(revision 9794)
+++ prs_app.c	(working copy)
@@ -86,6 +86,7 @@
 
 // this function is called from the fsm at the end of an rf slot
 // make sure that it terminates in time
+// typically called ever 13ms based on TDMA protocol (holds for V5 stack)
 #separate
 void SlotEndCallBack()
 {
